import type { ProjectTemplate } from "../../types";

export const HeadlampTool: ProjectTemplate = {
    name: "Headlamp",
    description: "Kubernetes Web UI",
    notes: "Requires Docker. Works with the 'Local Kubernetes' template - start that first!",
    type: "opensource-app",
    category: "Tool",
    icon: "fas fa-cubes text-blue-500",
    templating: [
        {
            action: 'file',
            file: 'docker-compose.yml',
            filecontent: `services:
  headlamp:
    image: ghcr.io/headlamp-k8s/headlamp:latest
    pull_policy: if_not_present
    restart: unless-stopped
    ports:
      - "4466:4466"
    environment:
      - HEADLAMP_CONFIG_KUBECONFIG=/home/headlamp/.kube/config
    volumes:
      # Mount the patched kubeconfig (generated by index.js)
      - ./kubeconfig_docker.yaml:/home/headlamp/.kube/config:ro
    healthcheck:
      test: ["CMD", "wget", "--spider", "-q", "http://localhost:4466"]
      interval: 10s
      timeout: 5s
      retries: 5
    extra_hosts:
      # Allow container to reach host's localhost (for K3s API)
      - "host.docker.internal:host-gateway"`
        },
        {
            action: 'file',
            file: '.gitignore',
            filecontent: `# Runtime file
.runtime.json
kubeconfig_docker.yaml
`
        },
        {
            action: 'file',
            file: 'index.js',
            filecontent: `const http = require('http');
const { spawn, exec } = require('child_process');
const fs = require('fs');
const path = require('path');

const RUNTIME_FILE = path.join(__dirname, '.runtime.json');
const SOURCE_KUBECONFIG = path.join(__dirname, '../local-kubernetes/kubeconfig_host.yaml');
const DOCKER_KUBECONFIG = path.join(__dirname, 'kubeconfig_docker.yaml');

console.log('Starting Headlamp...');

// Step 1: Patch kubeconfig for Docker (replace 127.0.0.1 with host.docker.internal)
const patchKubeconfig = () => {
    if (!fs.existsSync(SOURCE_KUBECONFIG)) {
        console.log('\\x1b[33mWarning:\\x1b[0m Local Kubernetes kubeconfig not found at:');
        console.log('  ' + SOURCE_KUBECONFIG);
        console.log('\\nPlease start the Local Kubernetes template first!');
        console.log('Expected folder structure:');
        console.log('  tools/');
        console.log('    local-kubernetes/   <- Start this first');
        console.log('    headlamp/           <- This folder');
        process.exit(1);
    }

    try {
        let content = fs.readFileSync(SOURCE_KUBECONFIG, 'utf8');
        // Replace localhost/127.0.0.1 with host.docker.internal for Docker access
        content = content.replace(/server:\\s*https:\\/\\/127\\.0\\.0\\.1:/g, 'server: https://host.docker.internal:');
        content = content.replace(/server:\\s*https:\\/\\/localhost:/g, 'server: https://host.docker.internal:');
        // Add insecure-skip-tls-verify since K3s certificate doesn't include host.docker.internal
        content = content.replace(/(server:\\\\s*https:\\\\/\\\\/host\\\\.docker\\\\.internal:[^\\\\n]+)/g, '$1\\n    insecure-skip-tls-verify: true');
        // Remove certificate-authority-data since we're skipping TLS verify
        content = content.replace(/\\\\n\\\\s*certificate-authority-data:[^\\\\n]+/g, '');
        fs.writeFileSync(DOCKER_KUBECONFIG, content);
        console.log('Created Docker-compatible kubeconfig (TLS verification disabled)');
    } catch(e) {
        console.error('Failed to patch kubeconfig:', e.message);
        process.exit(1);
    }
};

patchKubeconfig();

// Step 2: Start Docker Compose
const child = spawn('docker', ['compose', 'up', '-d', '--remove-orphans'], { stdio: 'inherit' });

child.on('close', (code) => {
    if (code !== 0) process.exit(code);
    // Follow logs with filtering
    const logs = spawn('docker', ['compose', 'logs', '-f', '--tail=0'], { stdio: ['ignore', 'pipe', 'pipe'] });
    
    const printImportant = (data) => {
        const lines = data.toString().split('\\n');
        lines.forEach(line => {
            let cleanLine = line.replace(/^[^|]+\\|\\s+/, '');
            const lower = cleanLine.toLowerCase();
            if (lower.includes('error') || lower.includes('fatal') || lower.includes('panic')) {
                process.stdout.write('\\x1b[31mError:\\x1b[0m ' + cleanLine + '\\n');
            }
        });
    };

    logs.stdout.on('data', printImportant);
    logs.stderr.on('data', printImportant);
    logs.on('close', (c) => process.exit(c || 0));
});

// Setup Control Server
const server = http.createServer((req, res) => {
    if (req.url === '/stop') {
        res.writeHead(200);
        res.end('Stopping...');
        cleanup();
    } else {
        res.writeHead(404);
        res.end();
    }
});

server.listen(0, () => {
    // We update runtime file later when we get the container ID
});

// Check status loop
const checkStatus = () => {
    exec('docker compose port headlamp 4466', (err, stdout, stderr) => {
        if (err || stderr || !stdout) {
            setTimeout(checkStatus, 2000);
            return;
        }
        const port = stdout.trim().split(':')[1];
        if (!port) {
            setTimeout(checkStatus, 2000);
            return;
        }

        // Verify headlamp is responding
        http.get(\`http://localhost:\${port}\`, (res) => {
            exec('docker compose ps -q', (err2, stdout2) => {
                const containerIds = stdout2 ? stdout2.trim().split('\\n') : [];
                
                try {
                    fs.writeFileSync(RUNTIME_FILE, JSON.stringify({ 
                        port: server.address().port, 
                        pid: process.pid,
                        containerIds: containerIds
                    }));
                } catch(e) {
                    console.error('Failed to write runtime file:', e);
                }

                process.stdout.write('\\\\x1Bc');
                console.log('\\n==================================================');
                console.log('â˜¸ï¸  Headlamp - Kubernetes Web UI');
                console.log('==================================================');
                console.log(\`URL:               http://localhost:\${port}\`);
                console.log('--------------------------------------------------');
                console.log('ðŸ”— Connected to: ../local-kubernetes');
                console.log('   Kubeconfig patched for Docker networking');
                console.log('--------------------------------------------------');
                console.log('ðŸ“š n8n Integration:');
                console.log('   Use Kubernetes node or HTTP Request');
                console.log('   Docs: https://headlamp.dev/docs/latest/');
                console.log('==================================================\\n');
            });
        }).on('error', () => {
            setTimeout(checkStatus, 2000);
        });
    });
};

setTimeout(checkStatus, 3000);

const cleanup = () => {
    console.log('Stopping Headlamp...');
    exec('docker compose down', (err, stdout, stderr) => {
        try { fs.unlinkSync(RUNTIME_FILE); } catch(e) {}
        try { fs.unlinkSync(DOCKER_KUBECONFIG); } catch(e) {}
        process.exit(0);
    });
};

process.on('SIGINT', cleanup);
process.on('SIGTERM', cleanup);`
        },
        {
            action: 'command',
            cmd: 'npm',
            args: ['pkg', 'set', 'scripts.start=node index.js']
        },
        {
            action: 'command',
            cmd: 'npm',
            args: ['pkg', 'set', 'scripts.stop=node -e \'const fs=require("fs"); try{const p=JSON.parse(fs.readFileSync(".runtime.json")).port; fetch("http://localhost:"+p+"/stop").catch(e=>{})}catch(e){}\'']
        },
        {
            action: 'command',
            cmd: 'npm',
            args: ['pkg', 'set', 'description=Headlamp - Kubernetes Web UI']
        },
        {
            action: 'command',
            cmd: 'npm',
            args: ['pkg', 'set', 'fontawesomeIcon=fas fa-cubes text-blue-500']
        },
        {
            action: 'command',
            cmd: 'npm',
            args: ['pkg', 'set', 'appType=tool']
        }
    ]
};
